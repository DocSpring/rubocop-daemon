#!/bin/bash
set -e

find_project_root() {
  path=$(pwd)
  while [[ "$path" != "" && ! -f "$path/Gemfile" && ! -f "$path/gems.rb" ]]; do
    path=${path%/*}
  done
  echo "$path"
}

PROJECT_ROOT="$(find_project_root)"
if [ -z "$PROJECT_ROOT" ]; then
  echo "Could not find Gemfile or gems.rb in $PWD or any parent directories!" >&2
  exit 1
fi

CACHE_DIR="$HOME/.cache/rubocop-daemon"
PROJECT_CACHE_KEY="$(echo ${PROJECT_ROOT:1} | tr '/' '+')"
PROJECT_CACHE_DIR="$CACHE_DIR/$PROJECT_CACHE_KEY"
TOKEN_PATH="$PROJECT_CACHE_DIR/token"
PORT_PATH="$PROJECT_CACHE_DIR/port"
STDIN_PATH="$PROJECT_CACHE_DIR/stdin"
STATUS_PATH="$PROJECT_CACHE_DIR/status"

# If -s or --stdin args are present, read stdin with `cat`
for ARG in $@; do
  if [ -z "$STDIN_CONTENT" ] && [ "$ARG" == "--stdin" ] || [ "$ARG" == "-s" ]; then
    STDIN_CONTENT="\n$(cat)"
  fi
done

if [ ! -f "$TOKEN_PATH" ]; then
  rubocop-daemon start
fi

run_rubocop_command() {
  TOKEN="$(cat "$TOKEN_PATH")"
  PORT="$(cat "$PORT_PATH")"
  COMMAND="$TOKEN $PWD exec $@"
  rm -f "$STATUS_PATH" # Clear the previous status
  if echo -e "$COMMAND${STDIN_CONTENT}" | nc localhost "$PORT"; then
    if [ -f "$STATUS_PATH" ]; then
      exit "$(cat $STATUS_PATH)"
    else
      echo "rubocop-daemon-wrapper: server did not write status to $STATUS_PATH!" >&2
      exit 1
    fi
  fi
  return 1
}

if ! run_rubocop_command $@; then
  echo "rubocop-daemon-wrapper: Error sending command to localhost:$PORT ($COMMAND)" >&2
  echo "Killing all rubocop-daemon processes and removing cache directory..." >&2
  rm -rf "$CACHE_DIR"
  pkill "rubocop-daemon "
  echo "Starting new rubocop-daemon server..." >&2
  rubocop-daemon start
  if ! run_rubocop_command $@; then
    echo "Sorry, something went wrong with rubocop-daemon!" >&2
    echo "Please try updating the gem or re-installing the rubocop-daemon-wrapper script."
    echo "If that doesn't work, please open an issue on GitHub:" \
      "https://github.com/fohte/rubocop-daemon/issues/new" >&2
  fi
fi
